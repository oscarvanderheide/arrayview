<!DOCTYPE html>
<html>
<head>
    <style>
        :root {
            --bg: #111; --surface: #1e1e1e; --border: #444;
            --text: #ccc; --muted: #777; --subtle: #444;
            --highlight: #fff; --canvas-border: #555;
        }
        html, body {
            background: var(--bg); margin: 0; padding: 0;
            width: 100%; height: 100%; overflow: hidden;
        }
        #wrapper {
            background: var(--bg); color: var(--text); font-family: monospace;
            display: flex; flex-direction: column; align-items: center;
            padding: 16px 20px 20px; width: 100%; height: 100%; box-sizing: border-box;
        }
        #wrapper.light {
            --bg: #f0f0f0; --surface: #e0e0e0; --border: #bbb;
            --text: #333; --muted: #888; --subtle: #bbb;
            --highlight: #000; --canvas-border: #999;
        }
        #info { margin-bottom: 12px; font-size: 16px; white-space: nowrap; text-align: left; flex-shrink: 0; }

        #viewer-row {
            display: flex; align-items: center; justify-content: center; flex: 1;
            min-height: 0; width: 100%; overflow: auto; padding: 20px; box-sizing: border-box;
        }

        #canvas-wrap { position: relative; display: inline-flex; justify-content: center; align-items: center; }
        canvas { border: 1px solid var(--canvas-border); image-rendering: pixelated; outline: none; cursor: crosshair; }
        #colorbar { display: none; position: absolute; left: 100%; top: 0; margin-left: 6px; border: none; cursor: default; }
        .highlight { color: var(--highlight); font-weight: bold; }
        .active-dim { color: #ebcb8b; font-weight: bold; }
        .muted { color: var(--muted); }
        #status { margin-top: 8px; font-size: 13px; color: var(--muted); min-height: 1.2em; flex-shrink: 0; }
        #pixel-info { margin-top: 2px; font-size: 12px; color: var(--text); min-height: 1em; font-family: monospace; flex-shrink: 0; }
        #preload-status { margin-top: 4px; font-size: 12px; color: var(--subtle); min-height: 1em; flex-shrink: 0; }
        #toast {
            margin-top: 8px; font-size: 13px; color: var(--text);
            min-height: 1.2em; opacity: 0; transition: opacity 0.8s ease; flex-shrink: 0;
        }
        #help-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); z-index: 10; justify-content: center; align-items: center;
        }
        #help-overlay.visible { display: flex; }
        #help-box {
            background: var(--surface); border: 1px solid var(--border); border-radius: 10px;
            padding: 30px 40px; font-size: 15px; line-height: 2; color: var(--text);
            white-space: pre;
        }
        #help-box .key { color: var(--highlight); font-weight: bold; display: inline-block; min-width: 140px; }
        #help-hint { position: fixed; bottom: 12px; right: 16px; color: var(--muted); font-size: 14px; cursor: pointer; font-family: monospace; user-select: none; }
        #data-info { margin-top: 8px; font-size: 13px; color: var(--text); white-space: pre; opacity: 0; transition: opacity 0.4s ease; pointer-events: none; }
        #multi-view-wrap { display: none; width: 100%; height: 100%; gap: 8px; }
        #multi-view-wrap.active { display: flex; align-items: stretch; justify-content: space-evenly; }
        .mv-pane { display: flex; flex-direction: column; align-items: center; gap: 6px; flex: 1; min-width: 0; min-height: 0; overflow: hidden; }
        .mv-label { font-size: 12px; color: var(--muted); flex-shrink: 0; font-family: monospace; }
        .mv-canvas-area { flex: 1; display: flex; align-items: center; justify-content: center; min-height: 0; width: 100%; }
        .mv-canvas { border: 1px solid var(--canvas-border); image-rendering: pixelated; cursor: crosshair; }
    </style>
</head>
<body>
<div id="wrapper">
    <div id="info">Connecting...</div>
    <div id="viewer-row">
        <div id="canvas-wrap">
            <canvas id="viewer" tabindex="0"></canvas>
            <canvas id="colorbar"></canvas>
        </div>
        <div id="multi-view-wrap"></div>
    </div>
    <textarea id="keyboard-sink" autocomplete="off" autocorrect="off" spellcheck="false"
              style="position:fixed;top:-1px;left:-1px;width:1px;height:1px;opacity:0;border:none;padding:0;margin:0;resize:none;overflow:hidden;"></textarea>
    <div id="status"></div>
    <div id="pixel-info"></div>
    <div id="toast"></div>
    <div id="preload-status"></div>
    <div id="help-hint">?</div>
    <div id="data-info"></div>
    <div id="help-overlay">
        <div id="help-box"><span class="key">scroll</span>  previous / next slice (active dim)
<span class="key">h / l / ← / →</span>  move cursor to prev / next dim
<span class="key">j / ↓</span>  on x/y: flip axis  |  else: prev index
<span class="key">k / ↑</span>  on x/y: flip axis  |  else: next index
<span class="key">L</span>  toggle log scale
<span class="key">x</span>  swap horizontal dim with slice dim
<span class="key">y</span>  swap vertical dim with slice dim
<span class="key">Space</span>  toggle auto-play
<span class="key">z</span>  claim dim as z (grid), scroll through next dim
<span class="key">m</span>  cycle complex mode (mag/phase/real/imag)
<span class="key">i</span>  show data info overlay
<span class="key">f</span>  toggle centred FFT (prompts for axes)
<span class="key">c</span>  cycle colormap
<span class="key">d</span>  cycle dynamic range
<span class="key">b</span>  toggle colorbar
<span class="key">t</span>  toggle dark / light theme
<span class="key">s</span>  save screenshot (PNG)
<span class="key">g</span>  save GIF of current slice dim
<span class="key">+ / -</span>  zoom in / out
<span class="key">0</span>  reset zoom (fit to window)
<span class="key">hover</span>  show pixel value
<span class="key">v</span>  toggle 3-plane view (prompts for spatial dims)
<span class="key">?</span>  toggle this help</div>
    </div>
</div>
    <script>
        const COLORMAPS = __COLORMAPS__;
        const DR_LABELS = __DR_LABELS__;
        const COLORMAP_GRADIENT_STOPS = __COLORMAP_GRADIENT_STOPS__;
        const COMPLEX_MODES = __COMPLEX_MODES__;
        const REAL_MODES = __REAL_MODES__;

        const urlParams = new URLSearchParams(window.location.search);
        const sid = urlParams.get('sid');

        let shape = [];
        let dim_x = 0, dim_y = 1, current_slice_dim = 2;
        let activeDim = 2;
        let indices = [];
        let colormap_idx = 0, dr_idx = 1;
        let isPlaying = false, playInterval = null;
        let dim_z = -1;
        let lastDirection = 1;
        let isDark = true;
        let isComplex = false;
        let complexMode = 0;

        let showColorbar = false;
        let currentVmin = 0, currentVmax = 1;
        let lastImageData = null, lastImgW = 0, lastImgH = 0;

        let ws = null, wsReady = false, wsSentSeq = 0;
        let isRendering = false;
        let pendingRequest = false;

        let preloadPolling = null;
        let preloadActiveDim = -1;
        let toastTimer = null;
        let dataInfoTimer = null;

        let userZoom = 1.0;
        let pixelHoverPending = false;
        let flip_x = false, flip_y = false;
        let _fftActive = false;
        let logScale = false;
        let multiViewActive = false;
        let mvViews = [];

        const canvas = document.getElementById('viewer');
        const ctx = canvas.getContext('2d');
        const colorbarCanvas = document.getElementById('colorbar');
        const cbCtx = colorbarCanvas.getContext('2d');
        const sink = document.getElementById('keyboard-sink');

        if (!sid) {
            document.getElementById('info').textContent = "No session ID provided in URL.";
        }

        function getBaseScale(w, h) {
            const row = document.getElementById('viewer-row');
            const maxW = Math.max(100, row.clientWidth - 40);
            const maxH = Math.max(100, row.clientHeight - 40);
            if (maxW <= 0 || maxH <= 0) return 1.0;
            return Math.min(maxW / w, maxH / h);
        }

        function scaleCanvas(w, h) {
            const baseScale = getBaseScale(w, h);
            const finalScale = baseScale * userZoom;
            canvas.style.width  = Math.round(w * finalScale) + 'px';
            canvas.style.height = Math.round(h * finalScale) + 'px';
            if (showColorbar) drawColorbar();
        }

        window.addEventListener('resize', () => {
            if (multiViewActive) { mvViews.forEach(v => mvScaleCanvas(v)); return; }
            if (lastImgW && lastImgH) scaleCanvas(lastImgW, lastImgH);
        });

        function showToast(msg) {
            const el = document.getElementById('toast');
            el.textContent = msg;
            el.style.transition = 'none';
            el.style.opacity = '1';
            if (toastTimer) clearTimeout(toastTimer);
            toastTimer = setTimeout(() => {
                el.style.transition = 'opacity 0.8s ease';
                el.style.opacity = '0';
            }, 1500);
        }

        function drawColorbar() {
            const stops = COLORMAP_GRADIENT_STOPS[COLORMAPS[colormap_idx]];
            const n = stops.length;
            const dpr = window.devicePixelRatio || 1;
            const cssH = parseInt(canvas.style.height);
            const cbCSSW = 50, barW = 14, barX = 8;
            const barH = Math.max(60, cssH - 40);
            const barY = Math.floor((cssH - barH) / 2);

            colorbarCanvas.width = Math.round(cbCSSW * dpr);
            colorbarCanvas.height = Math.round(cssH * dpr);
            colorbarCanvas.style.width = cbCSSW + 'px';
            colorbarCanvas.style.height = cssH + 'px';
            cbCtx.scale(dpr, dpr);

            for (let row = 0; row < barH; row++) {
                const t = 1 - row / (barH - 1);
                const fi = t * (n - 1);
                const lo = Math.floor(fi), hi = Math.min(lo + 1, n - 1);
                const frac = fi - lo;
                const r = Math.round(stops[lo][0] * (1 - frac) + stops[hi][0] * frac);
                const g = Math.round(stops[lo][1] * (1 - frac) + stops[hi][1] * frac);
                const b = Math.round(stops[lo][2] * (1 - frac) + stops[hi][2] * frac);
                cbCtx.fillStyle = `rgb(${r},${g},${b})`;
                cbCtx.fillRect(barX, barY + row, barW, 1);
            }

            cbCtx.strokeStyle = '#888'; cbCtx.lineWidth = 1;
            cbCtx.strokeRect(barX - 0.5, barY - 0.5, barW + 1, barH + 1);

            const fmt = v => {
                const av = Math.abs(v);
                if (av === 0) return '0';
                if (av >= 1e4 || (av < 1e-2 && av > 0)) return v.toExponential(2);
                return parseFloat(v.toPrecision(3)).toString();
            };
            cbCtx.font = '10px monospace';
            cbCtx.textAlign = 'left';
            cbCtx.fillStyle = isDark ? '#ddd' : '#222';
            const labelX = barX + barW + 3;
            cbCtx.fillText(fmt(currentVmax), labelX, barY + 9);
            cbCtx.fillText(fmt(currentVmin), labelX, barY + barH);
        }

        function showDataInfo(text) {
            const el = document.getElementById('data-info');
            el.textContent = text;
            el.style.transition = 'none';
            el.style.opacity = '1';
            if (dataInfoTimer) clearTimeout(dataInfoTimer);
            dataInfoTimer = setTimeout(() => {
                el.style.transition = 'opacity 0.8s ease';
                el.style.opacity = '0';
            }, 4000);
        }

        function applyFlips(imageData, w, h) {
            if (!flip_x && !flip_y) return imageData;
            const src = imageData.data;
            const out = new Uint8ClampedArray(src.length);
            for (let row = 0; row < h; row++) {
                const srcRow = flip_y ? (h - 1 - row) : row;
                for (let col = 0; col < w; col++) {
                    const srcCol = flip_x ? (w - 1 - col) : col;
                    const si = (srcRow * w + srcCol) * 4;
                    const di = (row * w + col) * 4;
                    out[di] = src[si]; out[di+1] = src[si+1];
                    out[di+2] = src[si+2]; out[di+3] = src[si+3];
                }
            }
            return new ImageData(out, w, h);
        }

        function initWebSocket() {
            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${proto}//${location.host}/ws/${sid}`);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                wsReady = true;
                setStatus('');
                sink.focus();
                updateView();
            };

            ws.onmessage = (event) => {
                const buf = event.data;
                const headerU32 = new Uint32Array(buf, 0, 3);
                const seq    = headerU32[0];
                const width  = headerU32[1];
                const height = headerU32[2];

                if (seq === wsSentSeq) {
                    const headerF32 = new Float32Array(buf, 12, 2);
                    currentVmin = headerF32[0];
                    currentVmax = headerF32[1];

                    const rgba = new Uint8ClampedArray(buf.slice(20));
                    lastImageData = new ImageData(rgba, width, height);
                    lastImgW = width; lastImgH = height;
                    canvas.width  = width;
                    canvas.height = height;
                    ctx.putImageData(applyFlips(lastImageData, width, height), 0, 0);
                    scaleCanvas(width, height);
                }

                isRendering = false;
                if (pendingRequest) {
                    pendingRequest = false;
                    updateView();
                }
            };

            ws.onclose = () => {
                wsReady = false;
                setStatus('WebSocket closed.');
            };

            ws.onerror = () => ws.close();
        }

        function triggerPreload() {
            if (multiViewActive) return;
            if (shape.length < 3) return;
            preloadActiveDim = current_slice_dim;
            fetch(`/preload/${sid}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    dim_x, dim_y, dim_z,
                    indices: [...indices],
                    colormap: COLORMAPS[colormap_idx],
                    dr: dr_idx,
                    complex_mode: complexMode,
                    log_scale: logScale,
                    slice_dim: current_slice_dim,
                })
            });
            if (preloadPolling) clearInterval(preloadPolling);
            preloadPolling = setInterval(pollPreloadStatus, 500);
        }

        function pollPreloadStatus() {
            fetch(`/preload_status/${sid}`).then(r => r.json()).then(data => {
                const el = document.getElementById('preload-status');
                if (data.skipped) {
                    el.textContent = 'Array too large for full preload (>500 MB).';
                    clearInterval(preloadPolling); preloadPolling = null;
                } else if (data.total > 0 && data.done >= data.total) {
                    el.textContent = '';
                    clearInterval(preloadPolling); preloadPolling = null;
                } else if (data.total > 0) {
                    const pct = Math.round(data.done / data.total * 100);
                    el.textContent = `Preloading dim ${preloadActiveDim}: ${data.done}/${data.total} (${pct}%)`;
                }
            }).catch(() => {
                clearInterval(preloadPolling); preloadPolling = null;
            });
        }

        async function init() {
            if (!sid) return;
            const res = await fetch(`/metadata/${sid}`);
            if (!res.ok) {
                document.getElementById('info').textContent = "Session expired or invalid.";
                return;
            }
            const data = await res.json();
            shape = data.shape;
            isComplex = data.is_complex || false;
            indices = shape.map(s => Math.floor(s / 2));
            dim_x = 0; dim_y = 1;
            current_slice_dim = shape.length > 2 ? 2 : 0;
            activeDim = current_slice_dim;
            initWebSocket();
            triggerPreload();
        }

        function getModeLabel() {
            return isComplex ? COMPLEX_MODES[complexMode] : REAL_MODES[complexMode];
        }

        function renderInfo() {
            const idxStr = indices.map((v, i) => {
                const active = (i === activeDim);
                if (i === dim_x) {
                    const inner = (flip_x ? '<span class="muted">-</span>' : '') + 'x';
                    return active ? `<span class="active-dim">${inner}</span>` : inner;
                }
                if (i === dim_y) {
                    const inner = (flip_y ? '<span class="muted">-</span>' : '') + 'y';
                    return active ? `<span class="active-dim">${inner}</span>` : inner;
                }
                if (i === dim_z) return active ? `<span class="active-dim">z</span>` : 'z';
                return active ? `<span class="active-dim">${v}</span>` : `${v}`;
            }).join(', ');
            let text = `[${idxStr}]`;
            if (isComplex || complexMode !== 0)
                text += `  <span class="muted">${getModeLabel()}</span>`;
            if (logScale)
                text += `  <span class="muted">log</span>`;
            if (_fftActive)
                text += `  <span class="muted">FFT</span>`;
            document.getElementById('info').innerHTML = text;
        }

        function setStatus(msg) { document.getElementById('status').textContent = msg; }

        function updateView() {
            renderInfo();
            if (multiViewActive) { mvViews.forEach(v => mvRender(v)); return; }
            if (!wsReady) return;

            if (isRendering) {
                pendingRequest = true;
                return;
            }

            isRendering = true;
            wsSentSeq++;
            ws.send(JSON.stringify({
                seq: wsSentSeq,
                dim_x, dim_y, dim_z,
                indices: [...indices],
                colormap: COLORMAPS[colormap_idx],
                dr: dr_idx,
                complex_mode: complexMode,
                log_scale: logScale,
                slice_dim: current_slice_dim,
                direction: lastDirection,
            }));
        }

        function stopPlay() {
            clearInterval(playInterval); playInterval = null;
            isPlaying = false; setStatus('');
        }

        function togglePlay() {
            if (isPlaying) { stopPlay(); return; }
            isPlaying = true;
            setStatus('▶ playing  (Space to stop)');
            playInterval = setInterval(() => {
                indices[current_slice_dim] = (indices[current_slice_dim] + 1) % shape[current_slice_dim];
                updateView();
            }, 80);
        }

        function saveScreenshot() {
            const link = document.createElement('a');
            link.download = `slice_${indices.join('-')}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            setStatus('Screenshot saved.');
            setTimeout(() => setStatus(''), 2000);
        }

        async function saveGif() {
            setStatus('Generating GIF...');
            const url = `/gif/${sid}?dim_x=${dim_x}&dim_y=${dim_y}&indices=${indices.join(',')}&colormap=${COLORMAPS[colormap_idx]}&dr=${dr_idx}&slice_dim=${current_slice_dim}`;
            const res = await fetch(url);
            const blob = await res.blob();
            const link = document.createElement('a');
            link.download = `dim${current_slice_dim}.gif`;
            link.href = URL.createObjectURL(blob);
            link.click();
            setStatus('GIF saved.');
            setTimeout(() => setStatus(''), 2000);
        }

        const helpOverlay = document.getElementById('help-overlay');

        // Allow clicks on canvas to auto-refocus keystrokes
        canvas.addEventListener('click', () => sink.focus());
        document.addEventListener('click', () => sink.focus());

        // This is crucial for tabs so key inputs don't get lost when swapping
        window.addEventListener('focus', () => sink.focus());

        canvas.addEventListener('mousemove', (e) => {
            if (dim_z >= 0) return;
            if (pixelHoverPending) return;
            pixelHoverPending = true;
            setTimeout(() => { pixelHoverPending = false; }, 50);
            const rect = canvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) * canvas.width / rect.width);
            const py = Math.floor((e.clientY - rect.top) * canvas.height / rect.height);
            fetch(`/pixel/${sid}?dim_x=${dim_x}&dim_y=${dim_y}&indices=${indices.join(',')}&px=${px}&py=${py}&complex_mode=${complexMode}`)
                .then(r => r.json())
                .then(d => {
                    const el = document.getElementById('pixel-info');
                    if (d.value !== undefined && isFinite(d.value)) {
                        const av = Math.abs(d.value);
                        const fmt = v => (av >= 1e4 || (av < 1e-2 && av > 0))
                            ? v.toExponential(3) : parseFloat(v.toPrecision(4)).toString();
                        el.textContent = `(${px}, ${py}) = ${fmt(d.value)}`;
                    } else {
                        el.textContent = '';
                    }
                });
        });
        canvas.addEventListener('mouseleave', () => {
            document.getElementById('pixel-info').textContent = '';
        });

        sink.addEventListener('keydown', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (e.key === '?') { helpOverlay.classList.toggle('visible'); return; }
            if (e.key === 'Escape') {
                helpOverlay.classList.remove('visible');
                return;
            }
            if (e.key === '+' || e.key === '=') {
                userZoom = Math.min(userZoom * 1.1, 10.0);
                scaleCanvas(canvas.width, canvas.height);
                showToast(`zoom: ${Math.round(userZoom * 100)}%`);
            } else if (e.key === '-') {
                userZoom = Math.max(userZoom / 1.1, 0.1);
                scaleCanvas(canvas.width, canvas.height);
                showToast(`zoom: ${Math.round(userZoom * 100)}%`);
            } else if (e.key === '0') {
                userZoom = 1.0;
                scaleCanvas(canvas.width, canvas.height);
                showToast(`zoom: fit`);
            } else if (e.key === 'b') {
                showColorbar = !showColorbar;
                colorbarCanvas.style.display = showColorbar ? 'block' : 'none';
                if (showColorbar && lastImageData) drawColorbar();
                showToast(showColorbar ? 'colorbar: on' : 'colorbar: off');
            } else if (e.key === 'z') {
                if (dim_z >= 0) {
                    current_slice_dim = dim_z;
                    dim_z = -1;
                } else {
                    if (shape.length < 4) return;
                    dim_z = current_slice_dim;
                    do { current_slice_dim = (current_slice_dim + 1) % shape.length; }
                    while (current_slice_dim === dim_x || current_slice_dim === dim_y || current_slice_dim === dim_z);
                }
                activeDim = current_slice_dim;
                updateView(); triggerPreload();
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlay();
            } else if (e.key === 't') {
                isDark = !isDark;
                document.getElementById('wrapper').classList.toggle('light', !isDark);
            } else if (e.key === 's') {
                saveScreenshot();
            } else if (e.key === 'g') {
                saveGif();
            } else if (e.key === 'm') {
                const modeCount = isComplex ? COMPLEX_MODES.length : REAL_MODES.length;
                complexMode = (complexMode + 1) % modeCount;
                updateView(); triggerPreload();
                showToast(`mode: ${getModeLabel()}`);
            } else if (e.key === 'c') {
                colormap_idx = (colormap_idx + 1) % COLORMAPS.length;
                fetch(`/clearcache/${sid}`); updateView(); triggerPreload();
                showToast(`colormap: ${COLORMAPS[colormap_idx]}`);
            } else if (e.key === 'd') {
                dr_idx = (dr_idx + 1) % DR_LABELS.length;
                fetch(`/clearcache/${sid}`); updateView(); triggerPreload();
                showToast(`range: ${DR_LABELS[dr_idx]}`);
            } else if (e.key === 'j' || e.key === 'ArrowDown') {
                e.preventDefault();
                if (activeDim === dim_x) {
                    flip_x = !flip_x;
                    if (lastImageData) ctx.putImageData(applyFlips(lastImageData, lastImgW, lastImgH), 0, 0);
                    renderInfo();
                } else if (activeDim === dim_y) {
                    flip_y = !flip_y;
                    if (lastImageData) ctx.putImageData(applyFlips(lastImageData, lastImgW, lastImgH), 0, 0);
                    renderInfo();
                } else {
                    lastDirection = -1;
                    indices[activeDim] = Math.max(0, indices[activeDim] - 1);
                    updateView();
                }
            } else if (e.key === 'k' || e.key === 'ArrowUp') {
                e.preventDefault();
                if (activeDim === dim_x) {
                    flip_x = !flip_x;
                    if (lastImageData) ctx.putImageData(applyFlips(lastImageData, lastImgW, lastImgH), 0, 0);
                    renderInfo();
                } else if (activeDim === dim_y) {
                    flip_y = !flip_y;
                    if (lastImageData) ctx.putImageData(applyFlips(lastImageData, lastImgW, lastImgH), 0, 0);
                    renderInfo();
                } else {
                    lastDirection = 1;
                    indices[activeDim] = Math.min(shape[activeDim] - 1, indices[activeDim] + 1);
                    updateView();
                }
            } else if (e.key === 'h' || e.key === 'ArrowLeft') {
                e.preventDefault();
                activeDim = (activeDim - 1 + shape.length) % shape.length;
                if (activeDim !== dim_x && activeDim !== dim_y && activeDim !== dim_z) {
                    current_slice_dim = activeDim; triggerPreload();
                }
                renderInfo();
            } else if (e.key === 'l' || e.key === 'ArrowRight') {
                e.preventDefault();
                activeDim = (activeDim + 1) % shape.length;
                if (activeDim !== dim_x && activeDim !== dim_y && activeDim !== dim_z) {
                    current_slice_dim = activeDim; triggerPreload();
                }
                renderInfo();
            } else if (e.key === 'L') {
                logScale = !logScale;
                fetch(`/clearcache/${sid}`); updateView(); triggerPreload();
                showToast(logScale ? 'log scale: on' : 'log scale: off');
            } else if (e.key === 'i') {
                fetch(`/info/${sid}`).then(r => r.json()).then(d => {
                    const lines = [
                        `Shape:    [${d.shape.join(', ')}]`,
                        `Dtype:    ${d.dtype}`,
                        `Elements: ${d.total_elements.toLocaleString()}`,
                        `Size:     ${d.size_mb !== null ? d.size_mb + ' MB' : 'unknown'}`,
                    ];
                    if (d.filepath) lines.push(`File:     ${d.filepath}`);
                    if (d.fft_axes) lines.push(`FFT axes: [${d.fft_axes.join(', ')}]`);
                    showDataInfo(lines.join('\n'));
                });
            } else if (e.key === 'f') {
                if (_fftActive) {
                    fetch(`/fft/${sid}`, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({axes: ''})})
                        .then(r => r.json()).then(d => {
                            _fftActive = false;
                            isComplex = d.is_complex || false;
                            if (!isComplex && complexMode >= REAL_MODES.length) complexMode = 0;
                            updateView(); triggerPreload();
                            showToast('FFT: off');
                        });
                } else {
                    const axesStr = window.prompt('FFT axes (comma-separated, e.g. 0,1):', '0,1');
                    if (!axesStr) return;
                    fetch(`/fft/${sid}`, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({axes: axesStr})})
                        .then(r => r.json()).then(d => {
                            if (d.error) { showToast('FFT error: ' + d.error); return; }
                            _fftActive = true;
                            isComplex = d.is_complex || false;
                            complexMode = 0;
                            updateView(); triggerPreload();
                            showToast(`FFT: [${d.axes.join(',')}]`);
                        });
                }
            } else if (e.key === 'x') {
                if (shape.length < 3) return;
                [dim_x, current_slice_dim] = [current_slice_dim, dim_x];
                dim_z = -1;
                updateView(); triggerPreload();
            } else if (e.key === 'y') {
                if (shape.length < 3) return;
                [dim_y, current_slice_dim] = [current_slice_dim, dim_y];
                dim_z = -1;
                updateView(); triggerPreload();
            } else if (e.key === 'v') {
                if (multiViewActive) exitMultiView(); else enterMultiView();
            }
        });


        // --------------- Multi-view (3-plane) ---------------
        function enterMultiView() {
            if (shape.length < 3) { showToast('Need at least 3 dimensions'); return; }
            const raw = window.prompt(
                `Spatial dims — enter 3 from 0\u2013${shape.length-1}, comma-separated:`, '0,1,2');
            if (raw === null) return;
            const dims = raw.split(',').map(s => parseInt(s.trim()));
            if (dims.length !== 3 || dims.some(isNaN) ||
                dims.some(d => d < 0 || d >= shape.length) || new Set(dims).size !== 3) {
                showToast('Enter 3 unique valid dimension indices'); return;
            }
            multiViewActive = true;
            document.getElementById('canvas-wrap').style.display = 'none';
            const wrap = document.getElementById('multi-view-wrap');
            wrap.innerHTML = '';
            wrap.classList.add('active');
            // 3 views: each shows a different pair of dims, slicing through the third
            const defs = [
                { dimX: dims[1], dimY: dims[0], sliceDir: dims[2] },
                { dimX: dims[2], dimY: dims[0], sliceDir: dims[1] },
                { dimX: dims[2], dimY: dims[1], sliceDir: dims[0] },
            ];
            mvViews = defs.map(def => {
                const pane = document.createElement('div');
                pane.className = 'mv-pane';
                const label = document.createElement('div');
                label.className = 'mv-label';
                label.textContent = `dim${def.dimY}\u00d7dim${def.dimX}  (\u2195 dim${def.sliceDir})`;
                const area = document.createElement('div');
                area.className = 'mv-canvas-area';
                const cv = document.createElement('canvas');
                cv.className = 'mv-canvas';
                area.appendChild(cv);
                pane.appendChild(label);
                pane.appendChild(area);
                wrap.appendChild(pane);
                const view = { dimX: def.dimX, dimY: def.dimY, sliceDir: def.sliceDir,
                    canvas: cv, ctx: cv.getContext('2d'), area,
                    ws: null, seq: 0, rendering: false, pending: false, lastW: 0, lastH: 0 };
                cv.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    indices[view.sliceDir] = e.deltaY > 0
                        ? Math.max(0, indices[view.sliceDir] - 1)
                        : Math.min(shape[view.sliceDir] - 1, indices[view.sliceDir] + 1);
                    renderInfo();
                    mvViews.forEach(v => mvRender(v));
                }, { passive: false });
                cv.addEventListener('click', (e) => {
                    sink.focus();
                    if (!view.lastW || !view.lastH) return;
                    const rect = cv.getBoundingClientRect();
                    const px = Math.floor((e.clientX - rect.left) * view.lastW / rect.width);
                    const py = Math.floor((e.clientY - rect.top) * view.lastH / rect.height);
                    indices[view.dimX] = Math.max(0, Math.min(shape[view.dimX] - 1, px));
                    indices[view.dimY] = Math.max(0, Math.min(shape[view.dimY] - 1, shape[view.dimY] - 1 - py));
                    renderInfo();
                    mvViews.forEach(v => mvRender(v));
                });
                return view;
            });
            mvViews.forEach(v => {
                const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
                v.ws = new WebSocket(`${proto}//${location.host}/ws/${sid}`);
                v.ws.binaryType = 'arraybuffer';
                v.ws.onopen = () => mvRender(v);
                v.ws.onmessage = (event) => mvOnMessage(v, event);
                v.ws.onerror = () => { if (v.ws) v.ws.close(); };
            });
            showToast('3-plane view  (v to exit)');
        }

        function exitMultiView() {
            multiViewActive = false;
            mvViews.forEach(v => { if (v.ws) { v.ws.onclose = null; v.ws.close(); } });
            mvViews = [];
            document.getElementById('canvas-wrap').style.display = '';
            const wrap = document.getElementById('multi-view-wrap');
            wrap.innerHTML = '';
            wrap.classList.remove('active');
            updateView();
            showToast('3-plane view: off');
        }

        function mvRender(v) {
            if (!v.ws || v.ws.readyState !== WebSocket.OPEN) return;
            if (v.rendering) { v.pending = true; return; }
            v.rendering = true; v.seq++;
            v.ws.send(JSON.stringify({
                seq: v.seq, dim_x: v.dimX, dim_y: v.dimY, dim_z: -1,
                indices: [...indices], colormap: COLORMAPS[colormap_idx],
                dr: dr_idx, complex_mode: complexMode, log_scale: logScale,
                slice_dim: v.sliceDir, direction: 1,
            }));
        }

        function mvOnMessage(v, event) {
            const buf = event.data;
            const h32 = new Uint32Array(buf, 0, 3);
            const width = h32[1], height = h32[2];
            if (h32[0] === v.seq) {
                const rgba = new Uint8ClampedArray(buf.slice(20));
                v.canvas.width = width; v.canvas.height = height;
                v.ctx.putImageData(new ImageData(rgba, width, height), 0, 0);
                v.lastW = width; v.lastH = height;
                mvScaleCanvas(v);
            }
            v.rendering = false;
            if (v.pending) { v.pending = false; mvRender(v); }
        }

        function mvScaleCanvas(v) {
            if (!v.lastW || !v.lastH) return;
            const maxW = Math.max(50, v.area.clientWidth - 4);
            const maxH = Math.max(50, v.area.clientHeight - 4);
            const scale = Math.min(maxW / v.lastW, maxH / v.lastH) * userZoom;
            v.canvas.style.width  = Math.round(v.lastW * scale) + 'px';
            v.canvas.style.height = Math.round(v.lastH * scale) + 'px';
        }

        helpOverlay.addEventListener('click', () => { helpOverlay.classList.remove('visible'); sink.focus(); });
        document.getElementById('help-hint').addEventListener('click', () => { helpOverlay.classList.toggle('visible'); sink.focus(); });

        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (multiViewActive) return;
            if (e.deltaY > 0) {
                lastDirection = -1;
                indices[current_slice_dim] = Math.max(0, indices[current_slice_dim] - 1);
            } else {
                lastDirection = 1;
                indices[current_slice_dim] = Math.min(shape[current_slice_dim] - 1, indices[current_slice_dim] + 1);
            }
            updateView();
        }, {passive: false});

        function closeSocket() {
            if (ws) {
                ws.onclose = null;
                ws.close();
            }
        }
        window.addEventListener('beforeunload', closeSocket);
        window.addEventListener('unload', closeSocket);
        window.addEventListener('pagehide', closeSocket);

        init();
    </script>
</body>
</html>
